
from __future__ import annotations
from typing import Dict, Optional, List, Tuple, Set
from .fol_ast import *
import re

# -------------------- Name handling --------------------
def _sanitize_symbol(name: str, *, is_var: bool=False) -> str:
    # TPTP: variables must start with uppercase; functors/preds with lowercase
    # We'll: 
    #   - replace spaces and illegal chars with '_'
    #   - enforce leading case
    s = re.sub(r'[^A-Za-z0-9_]', '_', name.strip())
    if not s:
        s = 'x' if is_var else 'c'
    if is_var:
        if not s[0].isupper():
            s = s[0].upper() + s[1:]
    else:
        if not s[0].islower():
            s = s[0].lower() + s[1:]
    return s

# -------------------- Pretty printers --------------------
def _pp_term(t: Term) -> str:
    if isinstance(t, Var):
        return _sanitize_symbol(t.name, is_var=True)
    if isinstance(t, Const):
        return _sanitize_symbol(t.name)
    if isinstance(t, Func):
        fname = _sanitize_symbol(t.name)
        args = ','.join(_pp_term(a) for a in t.args)
        return f"{fname}({args})" if t.args else fname
    raise TypeError(f"Unknown term: {t}")

def _pp_atom(a: Atom) -> str:
    if isinstance(a, Pred):
        pname = _sanitize_symbol(a.name)
        if a.args:
            return f"{pname}({','.join(_pp_term(x) for x in a.args)})"
        else:
            return pname
    if isinstance(a, Eq):
        return f"{_pp_term(a.left)} = {_pp_term(a.right)}"
    raise TypeError(f"Unknown atom: {a}")

def _pp_formula(phi: Formula) -> str:
    if isinstance(phi, AtomF):
        return _pp_atom(phi.atom)
    if isinstance(phi, Not):
        return f"~({_pp_formula(phi.phi)})"
    if isinstance(phi, And):
        return f"({_pp_formula(phi.left)} & {_pp_formula(phi.right)})"
    if isinstance(phi, Or):
        return f"({_pp_formula(phi.left)} | {_pp_formula(phi.right)})"
    if isinstance(phi, Implies):
        return f"({_pp_formula(phi.left)} => {_pp_formula(phi.right)})"
    if isinstance(phi, Iff):
        return f"({_pp_formula(phi.left)} <=> {_pp_formula(phi.right)})"
    if isinstance(phi, Forall):
        vs = ','.join(_pp_term(v) for v in phi.vars)
        return f"![{vs}] : ({_pp_formula(phi.body)})"
    if isinstance(phi, Exists):
        vs = ','.join(_pp_term(v) for v in phi.vars)
        return f"?[{vs}] : ({_pp_formula(phi.body)})"
    raise TypeError(f"Unknown formula: {phi}")

# -------------------- Problem builder --------------------
def to_tptp_problem(
    axioms: Dict[str, Formula],
    conjecture: Optional[Formula] = None,
    include_comments: bool = True,
    problem_name: str = "argfol_problem",
) -> str:
    """Render a set of axioms and (optional) conjecture into a TPTP FOF problem.

    :param axioms: mapping from *unique* axiom names to formulas
    :param conjecture: formula to prove from the axioms (optional)
    :return: TPTP text
    """
    lines: List[str] = []
    if include_comments:
        lines.append(f"% Generated by argfol.tptp for {problem_name}")
    used_names: Set[str] = set()
    def fresh(name: str) -> str:
        base = re.sub(r'[^A-Za-z0-9_]', '_', name.strip()) or 'ax'
        base = base.lower()
        n = base
        i = 1
        while n in used_names:
            i += 1
            n = f"{base}_{i}"
        used_names.add(n)
        return n

    for k, v in axioms.items():
        nm = fresh(k)
        lines.append(f"fof({nm}, axiom, {_pp_formula(v)})." )
    if conjecture is not None:
        lines.append(f"fof(conj, conjecture, {_pp_formula(conjecture)})." )
    return '\n'.join(lines) + '\n'
