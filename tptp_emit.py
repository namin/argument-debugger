# tptp_emit.py
# -*- coding: utf-8 -*-
"""
Emit TPTP/FOF from the mini-FOL strings carried in FOLPayload:
  - "forall x. P(x) -> Q(x)"     →  ![X] : ( P(X) => Q(X) )
  - "p => q"                      →  p => q
  - "p" / "q"                     →  p  /  q
  - "~q"                          →  ~ q
  - "pred(const)"                 →  pred(const)

Assumptions: only the simple forms produced by fol_synth.py are needed.
"""

from __future__ import annotations
import re
from typing import List

_vforall = re.compile(r'^\s*forall\s+([a-z]\w*)\s*\.\s*(.+)$', re.IGNORECASE)
_impl    = re.compile(r'^\s*(.+?)\s*(?:->|=>)\s*(.+?)\s*$')
_atom    = re.compile(r'^\s*([a-z][a-zA-Z0-9_]*)\s*(?:\(\s*([a-zA-Z0-9_ ,]+?)\s*\))?\s*$')
_neg     = re.compile(r'^\s*~\s*(.+?)\s*$')

def _uc_var(v: str) -> str:
    # TPTP variables must begin uppercase
    v = re.sub(r'[^A-Za-z0-9_]', '', v)
    if not v:
        return 'X'
    if not v[0].isalpha() or not v[0].isupper():
        v = 'X' + v
    return v

def _emit_atom(s: str, varmap=None) -> str:
    s = s.strip()
    m = _atom.match(s)
    if not m:
        # treat as 0-arity predicate name fallback
        return re.sub(r'[^a-z0-9_]', '_', s.lower())
    pred = m.group(1).lower()
    args = m.group(2)
    if not args:
        return pred
    parts = [a.strip() for a in args.split(',')]
    def _tr(a):
        if varmap and a in varmap:
            return varmap[a]
        # constants must be lower-case in TPTP
        return re.sub(r'[^a-z0-9_]', '_', a.lower())
    return f"{pred}({', '.join(_tr(a) for a in parts)})"

def _emit_formula(s: str) -> str:
    """Parse a simple formula into TPTP. Supports:
       - forall v. A(v) -> B(v)
       - A -> B, A => B
       - ~A
       - A (atom)
    """
    s = s.strip()
    # forall v. ...
    m = _vforall.match(s)
    if m:
        v = m.group(1)
        body = m.group(2).strip()
        XV = _uc_var(v)
        # Only support implication in the body for our use-cases
        m2 = _impl.match(body)
        if not m2:
            # Allow body to be an atom using v
            left = _emit_atom(body, varmap={v: XV})
            return f"![{XV}] : ( {left} )"
        left, right = m2.group(1).strip(), m2.group(2).strip()
        L = _emit_atom(left, varmap={v: XV})
        R = _emit_atom(right, varmap={v: XV})
        return f"![{XV}] : ( {L} => {R} )"

    # negation
    m = _neg.match(s)
    if m:
        inner = _emit_atom(m.group(1).strip())
        return f"~ {inner}"

    # implication (propositional form or atoms)
    m = _impl.match(s)
    if m:
        L = _emit_atom(m.group(1).strip())
        R = _emit_atom(m.group(2).strip())
        return f"{L} => {R}"

    # atom
    return _emit_atom(s)

def make_tptp_problem(premises: List[str], conclusion: str, name_prefix: str = "prob") -> str:
    """Return a complete TPTP/FOF problem as a string."""
    lines = ["% Generated by tptp_emit (mini-FOL → TPTP/FOF)"]
    for i, prem in enumerate(premises, 1):
        fof = _emit_formula(prem)
        lines.append(f"fof({name_prefix}_ax_{i}, axiom, ({fof})).")
    conj = _emit_formula(conclusion)
    lines.append(f"fof({name_prefix}_conj, conjecture, ({conj})).")
    return "\n".join(lines) + "\n"
