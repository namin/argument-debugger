# lean_bridge.py
# Minimal Lean 4 verifier for local propositional subgoals
# SPDX-License-Identifier: MIT

from __future__ import annotations
from logical_form_core import LFCore
from dataclasses import dataclass
from typing import List, Tuple, Dict, Optional, Set
import textwrap, tempfile, subprocess, os

# ---------- Data model ----------

@dataclass
class Subgoal:
    """
    A small, local inference problem:
      - atoms:   propositional atoms (identifiers for claims)
      - implications: list of (premise, conclusion) edges (P -> Q)
      - facts:   atoms assumed true (e.g., P)
      - goal:    target atom to derive (e.g., R)
      - name:    Lean theorem name for the artifact
    """
    atoms: List[str]
    implications: List[Tuple[str, str]]
    facts: List[str]
    goal: str
    name: str = "verified_goal"

@dataclass
class LeanVerificationResult:
    verified: bool
    lean_file: Optional[str]
    proof_chain: List[str]
    message: str = ""

# ---------- Core logic ----------

def _mangle(s: str) -> str:
    """Make a safe Lean identifier from an arbitrary claim id/label."""
    out = []
    for ch in s:
        if ch.isalnum():
            out.append(ch)
        else:
            out.append("_")
    out = "".join(out)
    if out and out[0].isdigit():
        out = "_" + out
    if not out:
        out = "_"
    return out

def _bfs_chain(starts: Set[str], goal: str, edges: List[Tuple[str,str]]) -> Optional[List[str]]:
    """
    Find a chain of atoms P0 -> P1 -> ... -> goal using implication edges.
    Returns the list of atoms along the chain if found, else None.
    """
    adj: Dict[str, List[str]] = {}
    for a,b in edges:
        adj.setdefault(a, []).append(b)

    from collections import deque
    q = deque()
    prev: Dict[str, Optional[str]] = {}

    for s in starts:
        q.append(s)
        prev[s] = None

    seen = set(starts)
    while q:
        u = q.popleft()
        if u == goal:
            # Reconstruct path
            chain = [u]
            while prev[chain[-1]] is not None:
                chain.append(prev[chain[-1]])
            chain.reverse()
            return chain
        for v in adj.get(u, []):
            if v not in seen:
                seen.add(v)
                prev[v] = u
                q.append(v)
    return None

def _render_lean(chain: List[str], used_edges: List[Tuple[str,str]], facts: List[str], name: str) -> str:
    """
    Emit a tiny Lean file that proves the goal from the used edges and a starting fact.
    We generate a constructive proof via 'have' steps—no external libraries needed.
    """
    # Unique atoms appearing in the theorem’s types
    atoms: List[str] = []
    for a,b in used_edges:
        if a not in atoms: atoms.append(a)
        if b not in atoms: atoms.append(b)
    for f in facts:
        if f not in atoms: atoms.append(f)

    lean_atoms = [ _mangle(a) for a in atoms ]
    lean_edges = [ (_mangle(a), _mangle(b)) for (a,b) in used_edges ]
    lean_facts = [ _mangle(f) for f in facts ]
    lean_chain = [ _mangle(x) for x in chain ]

    # Hypothesis names for edges and facts, in a stable order
    edge_hyps = [ f"h_{a}_{b}" for (a,b) in lean_edges ]
    fact_hyps = [ f"h_{p}" for p in lean_facts ]  # we’ll use the first that matches chain[0]

    # Build the body by chaining have-steps
    body_lines: List[str] = []
    # Determine the starting fact that matches chain[0]
    start_atom = lean_chain[0]
    try:
        start_idx = lean_facts.index(start_atom)
    except ValueError:
        # If the provided facts don’t include chain start, fall back to the first fact
        start_idx = 0
        start_atom = lean_facts[start_idx]

    cur = start_atom
    body_lines.append(f"  have h_{cur} : {cur} := {fact_hyps[start_idx]}")
    # map edges for quick lookup
    edge_map: Dict[Tuple[str,str], str] = {}
    for (hyp,(a,b)) in zip(edge_hyps, lean_edges):
        edge_map[(a,b)] = hyp

    for nxt in lean_chain[1:]:
        hyp = edge_map.get((cur, nxt))
        if hyp is None:
            # Shouldn’t happen if used_edges correspond to the chain
            hyp = "-- MISSING_EDGE_HYP"
        body_lines.append(f"  have h_{nxt} : {nxt} := {hyp} (h_{cur})")
        cur = nxt
    body_lines.append(f"  exact h_{cur}")

    # Put it all together
    atoms_decl = "\n".join([ f"axiom {a} : Prop" for a in lean_atoms ])
    # Theorem binders: edge hypotheses then fact hypothesis for the chosen start
    # Note: we only need the fact used to start the chain; others can be ignored.
    thm_binders = []
    for hyp,(a,b) in zip(edge_hyps, lean_edges):
        thm_binders.append(f"({hyp} : {a} → {b})")
    thm_binders.append(f"({fact_hyps[start_idx]} : {start_atom})")

    code = f"""\
/-! Auto-generated by Argument Debugger (Lean bridge).
    Proves the local subgoal from a chain of implications using only core Lean. -/

{atoms_decl}

theorem {name} {" ".join(thm_binders)} : {lean_chain[-1]} := by
{chr(10).join(body_lines)}
"""
    return textwrap.dedent(code)

def verify_with_lean(subgoal: Subgoal, lean_cmd: str = "lean") -> LeanVerificationResult:
    """
    Try to verify the subgoal by producing a Lean micro-proof (no mathlib needed).
    We:
      1) search for a chain of implications from one of the facts to the goal,
      2) emit a Lean file with a constructive proof over the used edges,
      3) run `lean` on that file; success => verified = True.
    """
    atoms: Set[str] = set(subgoal.atoms)
    # Basic guardrails
    if not subgoal.goal or (not subgoal.facts and not subgoal.implications):
        return LeanVerificationResult(False, None, [], "Ill-formed subgoal")

    # Find a chain
    chain = _bfs_chain(set(subgoal.facts), subgoal.goal, subgoal.implications)
    if chain is None or len(chain) < 2:
        return LeanVerificationResult(False, None, [], "No implication chain from facts to goal")

    # Extract used edges along the chain
    edges_set: Set[Tuple[str,str]] = set(subgoal.implications)
    used_edges: List[Tuple[str,str]] = []
    for i in range(len(chain)-1):
        step = (chain[i], chain[i+1])
        if step not in edges_set:
            return LeanVerificationResult(False, None, chain, f"Missing edge {step} in implications")
        used_edges.append(step)

    # Render Lean
    lean_code = _render_lean(chain, used_edges, subgoal.facts, subgoal.name)

    # Write to a temp file and run lean
    tmpdir = tempfile.mkdtemp(prefix="argdb_lean_")
    lean_path = os.path.join(tmpdir, f"{subgoal.name}.lean")
    with open(lean_path, "w", encoding="utf-8") as f:
        f.write(lean_code)

    try:
        proc = subprocess.run([lean_cmd, lean_path], capture_output=True, text=True)
        ok = (proc.returncode == 0)
        msg = proc.stdout if ok else (proc.stdout + "\n" + proc.stderr)
        return LeanVerificationResult(ok, lean_path, chain, msg)
    except FileNotFoundError:
        # Lean not installed / not on PATH; still return the artifact for inspection.
        return LeanVerificationResult(False, lean_path, chain, "Lean executable not found on PATH")

def verify_ui_with_lean(pred_P: str, pred_Q: str, const: str,
                        name: str = "ui_check", lean_cmd: str = "lean"):
    """
    Verify ∀x, P x -> Q x  and  P c   ⊢  Q c
    Generates a Lean file that should work in both Lean 3 and Lean 4.
    """
    import tempfile, os, subprocess

    def _mangle(s: str) -> str:
        # ASCII-only, Lean-safe identifier
        out = []
        for ch in s:
            if ("a" <= ch <= "z") or ("A" <= ch <= "Z") or ("0" <= ch <= "9") or ch == "_":
                out.append(ch)
            else:
                out.append("_")
        out = "".join(out)
        if not out:
            out = "x"
        if out[0].isdigit():
            out = "_" + out
        return out

    P = _mangle(pred_P)
    Q = _mangle(pred_Q)
    c = _mangle(const)
    thm = _mangle(name)

    code = f"""\
/- Auto-generated universal instantiation check -/
axiom T : Type
axiom {P} : T -> Prop
axiom {Q} : T -> Prop
axiom {c} : T

-- Term-mode proof (no tactics/macros needed):
theorem {thm} (h : forall x : T, {P} x -> {Q} x) (hp : {P} {c}) : {Q} {c} :=
  h {c} hp
"""

    tmpdir = tempfile.mkdtemp(prefix="argdb_lean_ui_")
    lean_path = os.path.join(tmpdir, f"{thm}.lean")
    with open(lean_path, "w", encoding="utf-8") as f:
        f.write(code)

    try:
        proc = subprocess.run([lean_cmd, lean_path], capture_output=True, text=True)
        ok = (proc.returncode == 0)
        msg = proc.stdout if ok else (proc.stdout + "\n" + proc.stderr)
        return ok, lean_path, msg
    except FileNotFoundError:
        return False, lean_path, "Lean executable not found on PATH"

if __name__ == "__main__":
    # Toy example: P → Q, Q → R, P ⊢ R
    sg = Subgoal(
        atoms=["P","Q","R"],
        implications=[("P","Q"),("Q","R")],
        facts=["P"],
        goal="R",
        name="demo_chain"
    )
    res = verify_with_lean(sg)

    if res.verified:
        print("Verified ✅ via Lean:", res.lean_file)
    else:
        print("Not verified ❌:", res.message, "\nArtifact:", res.lean_file)